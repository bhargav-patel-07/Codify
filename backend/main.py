"""
Main FastAPI application for the Coding Agent backend.
"""
from fastapi import FastAPI, HTTPException
from fastapi.middleware.cors import CORSMiddleware
from pydantic import BaseModel
import uvicorn
import os
from dotenv import load_dotenv

# Load environment variables
load_dotenv()

app = FastAPI(
    title="Coding Agent API",
    description="AI-powered coding assistant backend",
    version="1.0.0"
)

# Add CORS middleware
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],  # Configure this properly for production
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# Request/Response models
class CodeRequest(BaseModel):
    prompt: str
    language: str = "python"
    context: str = ""

class CodeResponse(BaseModel):
    code: str
    explanation: str
    status: str

class AnalysisRequest(BaseModel):
    code: str
    language: str = "python"

class AnalysisResponse(BaseModel):
    issues: list
    metrics: dict
    suggestions: list
    score: int

class ExecutionRequest(BaseModel):
    code: str
    language: str = "python"
    stdin: str = ""

class ExecutionResponse(BaseModel):
    stdout: str
    stderr: str
    exit_code: int
    execution_time: float
    language: str
    version: str

@app.get("/")
async def root():
    """Health check endpoint."""
    return {"message": "Coding Agent API is running", "status": "healthy"}

@app.get("/health")
async def health_check():
    """Detailed health check."""
    return {
        "status": "healthy",
        "version": "1.0.0",
        "services": {
            "api": "running",
            "agents": "ready",
            "workflows": "ready"
        }
    }

@app.post("/api/generate", response_model=CodeResponse)
async def generate_code(request: CodeRequest):
    """Generate code based on user prompt using AI with reliable fallback."""
    try:
        # First try Groq AI
        from backend.services.groq_service import code_generator as groq_generator
        
        result = groq_generator.generate_code(
            prompt=request.prompt,
            language=request.language,
            context=request.context
        )
        
        # Check if we got a real result or fallback template
        if (result["status"] == "success" and 
            len(result["code"]) > 50 and 
            "example_function" not in result["code"]):
            return CodeResponse(
                code=result["code"],
                explanation=result["explanation"] + " (Generated by AI)",
                status=result["status"]
            )
        
        # If Groq failed or returned template, use local generator
        from backend.services.local_code_generator import local_code_generator
        
        local_result = local_code_generator.generate_code(
            prompt=request.prompt,
            language=request.language,
            context=request.context
        )
        
        return CodeResponse(
            code=local_result["code"],
            explanation=local_result["explanation"] + " (Generated by local AI)",
            status=local_result["status"]
        )
        
    except Exception as e:
        # Final fallback if everything fails
        from backend.services.local_code_generator import local_code_generator
        
        try:
            fallback_result = local_code_generator.generate_code(
                prompt=request.prompt,
                language=request.language,
                context=request.context
            )
            
            return CodeResponse(
                code=fallback_result["code"],
                explanation=f"Generated using local AI (External AI unavailable: {str(e)})",
                status="success"
            )
        except:
            return CodeResponse(
                code=f"# Error: Could not generate code\n# Prompt: {request.prompt}\n# Please try a simpler request",
                explanation=f"All code generation methods failed: {str(e)}",
                status="error"
            )

@app.post("/api/analyze", response_model=AnalysisResponse)
async def analyze_code(request: AnalysisRequest):
    """Analyze code for issues, metrics, and suggestions."""
    try:
        # Import the code analyzer
        from backend.services.code_analyzer import code_analyzer
        
        # Analyze the code
        result = code_analyzer.analyze_code(
            code=request.code,
            language=request.language
        )
        
        return AnalysisResponse(
            issues=result["issues"],
            metrics=result["metrics"],
            suggestions=result["suggestions"],
            score=result["score"]
        )
        
    except Exception as e:
        # Fallback response if analysis fails
        return AnalysisResponse(
            issues=[{"type": "error", "line": 0, "message": str(e), "severity": "high"}],
            metrics={"lines_of_code": 0, "complexity_score": 0, "functions_count": 0, "classes_count": 0, "imports_count": 0},
            suggestions=["Code analysis failed - please check code syntax"],
            score=0
        )

@app.post("/api/execute", response_model=ExecutionResponse)
async def execute_code(request: ExecutionRequest):
    """Execute code safely using Piston API."""
    try:
        # Import the code executor
        from backend.services.code_executor import code_executor
        
        # Execute the code
        result = code_executor.execute_code(
            code=request.code,
            language=request.language,
            stdin=request.stdin
        )
        
        return ExecutionResponse(
            stdout=result.stdout,
            stderr=result.stderr,
            exit_code=result.exit_code,
            execution_time=result.execution_time,
            language=result.language,
            version=result.version
        )
        
    except Exception as e:
        # Fallback response if execution fails
        return ExecutionResponse(
            stdout="",
            stderr=f"Execution service error: {str(e)}",
            exit_code=1,
            execution_time=0.0,
            language=request.language,
            version="unknown"
        )

if __name__ == "__main__":
    port = int(os.getenv("PORT", 8000))
    uvicorn.run(app, host="0.0.0.0", port=port)
